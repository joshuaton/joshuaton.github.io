
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>通过源码理解Autorelease Pool原理 - 移动开发技术</title>
  <meta name="author" content="jason">

  
  <meta name="description" content="1. Autorelease Pool 是什么 iOS 的内存管理使用引用计数机制。当对象被初始化或者被强引用赋值时，对象的引用计数 +1，当对象离开所在函数作用域或者被设置为 nil 后，引用计数 -1。当对象的引用计数为 0 时，操作系统会释放掉对象所占用的内存。 我们先来看一下这段代码： 1 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jason5.cn/blog/tong-guo-yuan-ma-li-jie-autorelease-poolyuan-li.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="移动开发技术" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.9.1/jquery.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">移动开发技术</a></h1>
  
    <h2>Jason's Blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="jason5.cn">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">通过源码理解Autorelease Pool原理</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2019-06-01T20:52:49+08:00'><span class='date'>2019 年6 月1 日</span> <span class='time'>8:52 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><h2>1. Autorelease Pool 是什么</h2>

<p>iOS 的内存管理使用引用计数机制。当对象被初始化或者被强引用赋值时，对象的引用计数 +1，当对象离开所在函数作用域或者被设置为 nil 后，引用计数 -1。当对象的引用计数为 0 时，操作系统会释放掉对象所占用的内存。</p>

<!--more-->


<p>我们先来看一下这段代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="p">-(</span><span class="bp">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="nf">getObj</span><span class="p">{</span>
</span><span class='line'>    <span class="bp">NSObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 getObj 执行完后，obj 的作用域已经结束，obj 的引用计数为 0，应该马上被系统回收。那么问题就出现了，obj 是作为函数的返回给调用者的，被回收后调用者拿到的对象就是nil了，明显不符合调用者的预期。这时候 Autorelease Pool 就派上用场了，当 getObj 函数结束时，obj 并没有进行引用计数 -1 操作，而是将 obj 放入了 Autorelease Pool。Autorelease Pool 是一个可以存放多个对象指针的对象池，当 Autorelease Pool 被销毁时，会对所有 Autorelease Pool 中的对象执行引用计数 -1 操作，这时候才会回收 obj。相当于放入 Autorelease Pool 的对象被延迟释放了。这样的机制能够保证调用者能够正常拿取到 obj 的引用。</p>

<p>那么 Autorelease Pool 是什么时候被创建和销毁的呢？对于 ARC 来讲，大多数情况下，是不需要开发人员自己创建和销毁 Autorelease Pool 的（后面再讲少数情况）。Autorelease Pool 是在 Runloop 的一次循环中，被创建和释放的，是系统自己做的，开发人员不能控制创建和释放的时机，所以开发人员也不能知道 Autorelease Pool 里的对象什么时候被释放的。下边是网上看到的一个图，说明了 Autorelease Pool 创建和释放的时机。</p>

<p><img src="https://raw.githubusercontent.com/joshuaton/img/master/20190601222200.png" alt="" /></p>

<h2>2. AutoRelease Pool如何使用</h2>

<p>在 ARC 情况下，AutoRelease Pool 的使用非常简单，以 iOS 工程里的 main.m 代码为例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UIApplicationMain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">AppDelegate</span> <span class="k">class</span><span class="p">]));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>UIApplicationMain 的调用被 @autoreleasepool{} 整个包裹起来，表示 UIApplicationMain 函数执行之前，创建了一个 AutoRelease Pool，在函数返回之后，释放了之前创建的 AutoRelease Pool。在此期间，如果有对象要加入 AutoRelease Pool，就是加入的这个创建的 AutoRelease Pool。</p>

<p>上边提到，在大多数情况下，开发人员不需要自己创建和销毁自动释放池，现在谈一下少数情况。开发人员需要自己使用 AutoRelease Pool 的情形，通常是如下情况：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="err">    </span><span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'><span class="err">        </span><span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;hi + %d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="err">    </span><span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果不加上 @autoreleasepool{} 代码块，循环里的临时变量 str 会被加入到当前的 AutoRelease Pool，而这个 AutoRelease Pool 的释放时机，如上所说，是需要等到当前 Runloop 一个循环后才会释放，而这个时机我们并不能控制。这样，在 Runloop 一个循环结束前，就会出现很多临时变量 str 不用了，但是占用内存的情况。所以这里手动加上 @autoreleasepool{} 代码块，每次循环都创建一个新的 AutoRelease Pool， str 会被加入到这个新的 AutoRelease Pool，在每次 for 循环结束时，AutoRelease Pool 被释放，从而 str 也被及时释放，内存能够得到及时的清理。</p>

<h2>3. Autorelease Pool的实现原理</h2>

<p>我们从系统使用 @autoreleasepool{} 的代码入手，将 main.m 代码编译成 main.cpp 代码进行进一步分析，在 main.m 文件目录执行下面的编译命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk main.m
</span></code></pre></td></tr></table></div></figure>


<p>执行完后会生成文件 main.cpp，在文件最后会看到如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UIApplicationMain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">__null</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">(((</span><span class="n">Class</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;AppDelegate&quot;</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;class&quot;</span><span class="p">))));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，UIApplicationMain 执行前，增加了一行代码 <strong>AtAutoreleasePool </strong>autoreleasepool，这里声明了一个类型为 <strong>AtAutoreleasePool 的对象。在文件里搜索  </strong>AtAutoreleasePool，发现如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">__AtAutoreleasePool</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">__AtAutoreleasePool</span><span class="p">()</span> <span class="p">{</span><span class="n">atautoreleasepoolobj</span> <span class="o">=</span> <span class="n">objc_autoreleasePoolPush</span><span class="p">();}</span>
</span><span class='line'>  <span class="o">~</span><span class="n">__AtAutoreleasePool</span><span class="p">()</span> <span class="p">{</span><span class="n">objc_autoreleasePoolPop</span><span class="p">(</span><span class="n">atautoreleasepoolobj</span><span class="p">);}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span> <span class="n">atautoreleasepoolobj</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>__AtAutoreleasePool 是一个结构体，在构造函数和析构函数里，分别调用了 objc_autoreleasePoolPush() 和 objc_autoreleasePoolPop(atautoreleasepoolobj) 方法。也就是说，在 UIApplicationMain 执行前，首先先执行了 objc_autoreleasePoolPush 方法，然后执行了 objc_autoreleasePoolPop 方法，objc_autoreleasePoolPush 是在创建 Autorelease Pool，objc_autoreleasePoolPop 是在销毁 Autorelease Pool。接下来我们通过源码分析创建和销毁 Autorelease Pool 都做了什么。</p>

<p>这两个方法的代码在<code>NSObject.mm</code>里，代码是开源的，可以到 <a href="https://opensource.apple.com/release/macos-10141.html">https://opensource.apple.com/release/macos-10141.html</a> 下载，笔者查看的是最新的 objc4-750.1 版本。所有的历史版本可以在这里浏览 <a href="https://opensource.apple.com/source/objc4/">https://opensource.apple.com/source/objc4/</a> 。</p>

<h3>3.1 创建Autorelease Pool</h3>

<p>首先看 objc_autoreleasePoolPush 的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="o">*</span>
</span><span class='line'><span class="nf">objc_autoreleasePoolPush</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">AutoreleasePoolPage</span><span class="o">::</span><span class="n">push</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>objc_autoreleasePoolPush 的实现很简单，直接调用了AutoreleasePoolPage::push() 。先来看下 AutoreleasePoolPage 是什么：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">AutoreleasePoolPage</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">magic_t</span> <span class="k">const</span> <span class="n">magic</span><span class="p">;</span>
</span><span class='line'>    <span class="n">id</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">pthread_t</span> <span class="k">const</span> <span class="kr">thread</span><span class="p">;</span>
</span><span class='line'>    <span class="n">AutoreleasePoolPage</span> <span class="o">*</span> <span class="k">const</span> <span class="n">parent</span><span class="p">;</span>
</span><span class='line'>    <span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">depth</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">hiwat</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>省去其他的宏定义、常量定义和方法，AutoreleasePoolPage 有如上属性，parent 和 child 同样指向AutoreleasePoolPage， 很容易猜测 AutoreleasePoolPage 是双向链表中的一个节点，后续的代码会印证这个猜测。next 是一个指针，是一个比较重要的属性，先留意一下，后边会讲。其余的属性对理解 Autorelease Pool 原理不是特别重要，暂时先都忽略。</p>

<p>AutoreleasePoolPage 对象分配内存方法如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="err">    </span><span class="k">return</span> <span class="n">malloc_zone_memalign</span><span class="p">(</span><span class="n">malloc_default_zone</span><span class="p">(),</span> <span class="n">SIZE</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>SIZE 被定义为 PAGE_MAX_SIZE，PAGE_MAX_SIZE 是虚拟内存一页的大小，网上查资料说是0x1000字节。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="err">    </span><span class="k">static</span> <span class="kt">size_t</span> <span class="k">const</span> <span class="n">SIZE</span> <span class="o">=</span>
</span><span class='line'><span class="cp">#if PROTECT_AUTORELEASEPOOL</span>
</span><span class='line'>        <span class="n">PAGE_MAX_SIZE</span><span class="p">;</span>  <span class="c1">// must be multiple of vm page size</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>        <span class="n">PAGE_MAX_SIZE</span><span class="p">;</span>  <span class="c1">// size and alignment, power of 2</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以，一个 AutoreleasePoolPage 对象所占用的内存大小是 PAGE_MAX_SIZE。</p>

<p>看到这里我们已经清楚 AutoreleasePoolPage 的内部结构，用一张图来表示：</p>

<p><img src="https://raw.githubusercontent.com/joshuaton/img/master/20190602152848.png" alt="" /></p>

<p>除了存储 AutoreleasePoolPage 的成员变量外，其余空间会用来存储加入到 Autorelease Pool 的对象指针。</p>

<p>继续看 AutoreleasePoolPage::push 方法的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">push</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">id</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">DebugPoolAllocation</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Each autorelease pool starts on a new pool page.</span>
</span><span class='line'>        <span class="n">dest</span> <span class="o">=</span> <span class="n">autoreleaseNewPage</span><span class="p">(</span><span class="n">POOL_BOUNDARY</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">dest</span> <span class="o">=</span> <span class="n">autoreleaseFast</span><span class="p">(</span><span class="n">POOL_BOUNDARY</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">dest</span> <span class="o">==</span> <span class="n">EMPTY_POOL_PLACEHOLDER</span> <span class="o">||</span> <span class="o">*</span><span class="n">dest</span> <span class="o">==</span> <span class="n">POOL_BOUNDARY</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">dest</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>会调用 autoreleaseFast 方法，方法的参数是 POOL_BOUNDARY ，关于 POOL_BOUNDARY 是什么，这个之后再说：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="n">id</span> <span class="o">*</span><span class="nf">autoreleaseFast</span><span class="p">(</span><span class="n">id</span> <span class="n">obj</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">hotPage</span><span class="p">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">autoreleaseFullPage</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">autoreleaseNoPage</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先拿到当前的 hotPage，hotPage 可以理解为正在使用的 AutoreleasePoolPage，也就是双向链表末端的 AutoreleasePoolPage。然后分为三种情况：</p>

<ol>
<li><p>如果有 hotPage，并且 hotPage 没有满的时候，调用 page->add(obj)</p></li>
<li><p>如果有 hotPage，但是 hotPage 已经满的时候，调用 autoreleaseFullPage(obj, page)</p></li>
<li><p>如果没有 hotPage，调用 autoreleaseNoPage(obj)</p></li>
</ol>


<p>以下对 3 种情况分别进行说明：</p>

<p>第 1 种情况，查看 AutoreleasePoolPage 的 add 方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">id</span> <span class="o">*</span><span class="nf">add</span><span class="p">(</span><span class="n">id</span> <span class="n">obj</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">full</span><span class="p">());</span>
</span><span class='line'>    <span class="n">unprotect</span><span class="p">();</span>
</span><span class='line'>    <span class="n">id</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>  <span class="c1">// faster than `return next-1` because of aliasing</span>
</span><span class='line'>    <span class="o">*</span><span class="n">next</span><span class="o">++</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'>    <span class="n">protect</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>将 next 指针指向 obj， 然后next++，返回obj。所以，这里我们可以知道，AutoreleasePoolPage 的 next 指针是指向下一个空位置，当有对象要被加入到 AutoreleasePoolPage 的时候，会加入到这个位置。</p>

<p>第 2 种情况，查看 autoreleaseFullPage 的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">id</span> <span class="o">*</span><span class="nf">autoreleaseFullPage</span><span class="p">(</span><span class="n">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// The hot page is full. </span>
</span><span class='line'>    <span class="c1">// Step to the next non-full page, adding a new page if necessary.</span>
</span><span class='line'>    <span class="c1">// Then add the object to that page.</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">hotPage</span><span class="p">());</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">()</span>  <span class="o">||</span>  <span class="n">DebugPoolAllocation</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">)</span> <span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
</span><span class='line'>        <span class="k">else</span> <span class="n">page</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AutoreleasePoolPage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">());</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">setHotPage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>新建一个 page，将新建的 page 设置为 hotPage，并且将 obj 加入到此 page 中，通过进一步查看 AutoreleasePoolPage 的构造函数会发现，新 page 的 parent 指针会设置成这个函数传入的老 page，新老 page 就形成了双向链表的结构。</p>

<p>第 3 种情况，查看 autoreleaseNoPage 的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">id</span> <span class="o">*</span><span class="nf">autoreleaseNoPage</span><span class="p">(</span><span class="n">id</span> <span class="n">obj</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">pushExtraBoundary</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Install the first page.</span>
</span><span class='line'>    <span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AutoreleasePoolPage</span><span class="p">(</span><span class="n">nil</span><span class="p">);</span>
</span><span class='line'>    <span class="n">setHotPage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Push a boundary on behalf of the previously-placeholder&#39;d pool.</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">pushExtraBoundary</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">page</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">POOL_BOUNDARY</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Push the requested object or pool.</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>新建一个 AutoreleasePoolPage ，然后再加入 obj ，创建 Autorelease Pool 的时候，obj 的值是 POOL_BOUNDARY。</p>

<p>我们用一张图来表示 Autorelease Pool 创建时候的情况：</p>

<p><img src="https://raw.githubusercontent.com/joshuaton/img/master/20190602153813.png" alt="" /></p>

<p>在这里我们来说一下 POOL_BOUNDARY 是什么。我们可以发现其定义是为 nil</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="cp">#define POOL_BOUNDARY nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>从字面意义上来讲，这是一个边界标记，当每次创建一个新的 Autorelease Pool 时，我们都会首先加入一个 POOL_BOUNDARY 标记在内存中，这样我们就知道了不同 Autorelease Pool 的分割位置在哪里。当我们需要最后创建的 Autorelease Pool 中的所有对象时，我们就只要释放这个 POOL_BOUNDARY 位置之后的对象。</p>

<h3>3.2 将对象加入Autorelease Pool</h3>

<p>创建 Autorelease Pool 的代码到此就基本看完了，我们马上再来看下将一个对象加入 Autorelease Pool 会干些什么。将对象加入 Autorelease Pool 会调用 NSObject 的 autorelease 方法，实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="n">id</span> <span class="nf">autorelease</span><span class="p">(</span><span class="n">id</span> <span class="n">obj</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">isTaggedPointer</span><span class="p">());</span>
</span><span class='line'>    <span class="n">id</span> <span class="o">*</span><span class="n">dest</span> <span class="n">__unused</span> <span class="o">=</span> <span class="n">autoreleaseFast</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">dest</span>  <span class="o">||</span>  <span class="n">dest</span> <span class="o">==</span> <span class="n">EMPTY_POOL_PLACEHOLDER</span>  <span class="o">||</span>  <span class="o">*</span><span class="n">dest</span> <span class="o">==</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上是在调用 autoreleaseFast 方法。原来，创建一个 Autorelease Pool 和将一个 obj 加入 Autorelease Pool 其实代码流程是一样的，不同的是创建时候添加的是 POOL_BOUNDARY，添加时候添加的是 obj。</p>

<p>通过以上代码，我们知道往 Autorelease Pool 里添加多个对象后是什么情况了，用一张图来表示：</p>

<p><img src="https://raw.githubusercontent.com/joshuaton/img/master/20190602154506.png" alt="" /></p>

<p>假设我们有 obj0 到 obj4 一共 5 个对象需要添加进 Autorelease Pool。第一个 AutorelasePoolPage 没有用满时，直接往里边加，满了之后，新建一个 AutorelasePoolPage，在往里边继续加。所以，obj0、obj1、obj2、obj3 被添加到了第 1 个 AutorelasePoolPage 中，obj4 被添加到了第 2 个 AutorelasePoolPage 中。真实情况下，AutorelasePoolPage 当然不只存储 4 个对象，这里只是方便举例说明。</p>

<p>如果在 Autorelase Pool 没有销毁的时候，再新建一个 Autorelase Pool，则往 AutorelasePoolPage 的 next 位置加入 POOL_BOUNDARY。如果又有对象要添加进新的 Autorelase Pool，则往 AutorelasePoolPage 继续添加 obj5 和 obj6，如下图：</p>

<p><img src="https://raw.githubusercontent.com/joshuaton/img/master/20190602154735.png" alt="" /></p>

<p>可以看到，POOL_BOUNDARY 是边界对象，标识了多个 Autorelease Pool 的分割边界。</p>

<h3>3.3 销毁Autorelease Pool</h3>

<p>前边提到，销毁 Autorelease Pool 会调用 objc_autoreleasePoolPop 方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">objc_autoreleasePoolPop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="err">    </span><span class="n">AutoreleasePoolPage</span><span class="o">::</span><span class="n">pop</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>直接查看 AutoreleasePoolPage::pop 代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">token</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">id</span> <span class="o">*</span><span class="n">stop</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">page</span> <span class="o">=</span> <span class="n">pageForPointer</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
</span><span class='line'>    <span class="n">stop</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span> <span class="o">*</span><span class="p">)</span><span class="n">token</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">PrintPoolHiwat</span><span class="p">)</span> <span class="n">printHiwat</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">page</span><span class="o">-&gt;</span><span class="n">releaseUntil</span><span class="p">(</span><span class="n">stop</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// memory: delete empty children</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">DebugPoolAllocation</span>  <span class="o">&amp;&amp;</span>  <span class="n">page</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// special case: delete everything during page-per-pool debugging</span>
</span><span class='line'>        <span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
</span><span class='line'>        <span class="n">page</span><span class="o">-&gt;</span><span class="n">kill</span><span class="p">();</span>
</span><span class='line'>        <span class="n">setHotPage</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DebugMissingPools</span>  <span class="o">&amp;&amp;</span>  <span class="n">page</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">()</span>  <span class="o">&amp;&amp;</span>  <span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// special case: delete everything for pop(top) </span>
</span><span class='line'>        <span class="c1">// when debugging missing autorelease pools</span>
</span><span class='line'>        <span class="n">page</span><span class="o">-&gt;</span><span class="n">kill</span><span class="p">();</span>
</span><span class='line'>        <span class="n">setHotPage</span><span class="p">(</span><span class="nb">nil</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// hysteresis: keep one empty child if page is more than half full</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lessThanHalfFull</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">page</span><span class="o">-&gt;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">kill</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">page</span><span class="o">-&gt;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">kill</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>回顾下之前的代码，token 为创建 Autorelease Pool 时返回的 POOL_BOUNDARY，这个会作为 pageForPointer 的输入参数。 pageForPointer 函数的实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">static</span> <span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="nf">pageForPointer</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">pageForPointer</span><span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="nf">pageForPointer</span><span class="p">(</span><span class="kt">uintptr_t</span> <span class="n">p</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">uintptr_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">p</span> <span class="o">%</span> <span class="n">SIZE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">AutoreleasePoolPage</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
</span><span class='line'>    <span class="n">result</span><span class="o">-&gt;</span><span class="n">fastcheck</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过 POOL_BOUNDARY 的内存地址和 AutoreleasePoolPage 的内存占用 SIZE，可以算出 POOL_BOUNDARY 相对于 AutoreleasePoolPage 起始地址的偏移量，从而计算出创建 Autorelease Pool 时候的那个 AutoreleasePoolPage 的内存起始地址。所以，pageForPointer 函数返回当前 Autorelease Pool 创建时候的 AutoreleasePoolPage。</p>

<p>接下来看 page->releaseUntil(stop) 的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="kt">void</span> <span class="nf">releaseUntil</span><span class="p">(</span><span class="kt">id</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// Not recursive: we don&#39;t want to blow out the stack </span>
</span><span class='line'>    <span class="c1">// if a thread accumulates a stupendous amount of garbage</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Restart from hotPage() every time, in case -release </span>
</span><span class='line'>        <span class="c1">// autoreleased more objects</span>
</span><span class='line'>        <span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">hotPage</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// fixme I think this `while` can be `if`, but I can&#39;t prove it</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
</span><span class='line'>            <span class="n">setHotPage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">page</span><span class="o">-&gt;</span><span class="n">unprotect</span><span class="p">();</span>
</span><span class='line'>        <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="o">*--</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>        <span class="n">memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">SCRIBBLE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
</span><span class='line'>        <span class="n">page</span><span class="o">-&gt;</span><span class="n">protect</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="n">POOL_BOUNDARY</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">objc_release</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">setHotPage</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从当前的 hotPage 开始，依次对 AutoreleasePoolPage 里的对象执行 objc_release 操作，直到遇到 POOL_BOUNDARY 对象。这就是对当前 Autorelease Pool 里的所有对象进行释放操作。用一张图来表示这个过程会更加直观：</p>

<p><img src="https://raw.githubusercontent.com/joshuaton/img/master/Canvas%205.jpg" alt="" /></p>

<p>我们可以思考一下为什么要这么设计 Autorelease Pool。由于要加入 Autorelease Pool 的对象个数是不固定的，所以系统只能一次分配固定大小的内存，也就是一个 AutoreleasePoolPage的大小。当加满了之后，再在双向链表的最后加上一个 AutoreleasePoolPage。这里其实跟操作系统给应用程序分配内存空间是一样的，也是按页分配。而如何区分多个 Autorelease Pool，就是用了 POOL_BOUNDARY 来做边界标记。</p>

<h2>4. 总结</h2>

<p>到此位置，我们已经分析完了创建 Autorelease Pool，往 Autorelease Pool 里添加对象，释放 Autorelease Pool 的主要代码。其中还有一些分支代码和异常情况的处理被省略，感兴趣的同学可以自行查看其余源码。</p>

<p>最后我们总结一下 Autorelease Pool 的实现原理：</p>

<ol>
<li><p>Autorelease Pool 是由多个 AutoreleasePoolPage 对象以双向链表的方式组织起来的数据结构。</p></li>
<li><p>每个 AutoreleasePoolPage 只能存储有限个对象指针。当新的对象加入 Autorelease Pool 的时候，如果当前的 AutoreleasePoolPage 存储空间不够，会新初始化一个 AutoreleasePoolPage，加入到链表末端。</p></li>
<li><p>Autorelease Pool 可以被嵌套创建。创建一个新的 Autorelease Pool 的时候，会在当前 AutoreleasePoolPage 中插入边界对象 POOL_BOUNDARY，以和上一个 Autorelease Pool 以区分。</p></li>
<li><p>当 Autorelease Pool 销毁的时候，对 AutoreleasePoolPage 里存储的所有对象依次从后往前调用 release，直到遇到对象 POOL_BOUNDARY，表明当前 Autorelease Pool 中的对象已经被全部释放。</p></li>
</ol>


<h2>5. 参考资料</h2>

<p><a href="https://juejin.im/post/5a66e28c6fb9a01cbf387da1">https://juejin.im/post/5a66e28c6fb9a01cbf387da1</a></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">jason</span></span>

      




<time class='entry-date' datetime='2019-06-01T20:52:49+08:00'><span class='date'>2019 年6 月1 日</span> <span class='time'>8:52 pm</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/ios/'>ios</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/ji-%5B%3F%5D-ci-shu-ju-ku-bei-gong-ji-de-jing-li.html" title="Previous Post: 记一次数据库被攻击的经历">&laquo; 记一次数据库被攻击的经历</a>
      
      
        <a class="basic-alignment right" href="/blog/ios-zhong-de-nsproxy.html" title="Next Post: iOS 中的 NSProxy">iOS 中的 NSProxy &raquo;</a>
      
    </p>
  </footer>
</article>

<section>
  <h1>Comments</h1>
  <div id="container"></div>
</section>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
    id: '通过源码理解Autorelease Pool原理',
    owner: 'joshuaton',
    repo: 'joshuaton.github.io',
    oauth: {
        client_id: 'eec868eaacadc00f17c0',
        client_secret: '9840ef585828127e5f235ff6d2b28141ae182f98',
    },
});
gitment.render('container');
</script>


</div>

<aside class="sidebar">
  
    <section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/android/'>android (2)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (13)</a></li>
<li class='category'><a href='/blog/categories/other/'>other (9)</a></li>
<li class='category'><a href='/blog/categories/performance/'>performance (1)</a></li>
<li class='category'><a href='/blog/categories/security/'>security (4)</a></li>
<li class='category'><a href='/blog/categories/web/'>web (4)</a></li>
<li class='category'><a href='/blog/categories/weex/'>weex (5)</a></li>

  </ul>
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/hippyjie-ru-typescriptji-lu.html">Hippy接入typescript记录</a>
      </li>
    
      <li class="post">
        <a href="/blog/jiang-xian-you-jsku-gai-cheng-tsku.html">将现有js库改成ts库</a>
      </li>
    
      <li class="post">
        <a href="/blog/zai-xian-you-iosxiang-mu-zhong-ji-cheng-flutterfang-an.html">在现有iOS项目中集成Flutter方案</a>
      </li>
    
      <li class="post">
        <a href="/blog/bridge-bridge-retained-bridge-transferde-qu-bie.html">__bridge __bridge retained __bridge transfer的区别</a>
      </li>
    
      <li class="post">
        <a href="/blog/ios-zhong-de-nsproxy.html">iOS 中的 NSProxy</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2021 - jason -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
<script>
var _mtac = {};
(function() {
    var mta = document.createElement("script");
    mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.2";
    mta.setAttribute("name", "MTAH5");
    mta.setAttribute("sid", "500600841");
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(mta, s);
})();
</script>
            

</footer>
  











</body>
</html>
