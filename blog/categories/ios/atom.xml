<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：ios | 移动开发技术]]></title>
  <link href="http://jason5.cn/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://jason5.cn/"/>
  <updated>2019-01-07T22:34:06+08:00</updated>
  <id>http://jason5.cn/</id>
  <author>
    <name><![CDATA[jason]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Aspects源码解读]]></title>
    <link href="http://jason5.cn/blog/acpectsyuan-ma-jie-du.html"/>
    <updated>2019-01-07T15:25:12+08:00</updated>
    <id>http://jason5.cn/blog/acpectsyuan-ma-jie-du</id>
    <content type="html"><![CDATA[<p>Aspects是iOS面向切面编程的第三方库，它可以在不改变原有代码的情况下，在任意函数之前或之后插入代码，也可以替换掉函数原有的代码。它的原理是基于iOS的runtime，这篇文章对Aspects进行源码解读，并阐述其原理。</p>

<h2>调用方式</h2>

<p>首先我们下载官方demo，从入口代码开始看：</p>

<pre><code class="objective-c">AspectsViewController *aspectsController = [AspectsViewController new];
[aspectsController aspect_hookSelector:@selector(buttonPressed:) withOptions:0 usingBlock:^(id info, id sender) {
    NSLog(@"Button was pressed by: %@", sender);
} error:NULL];
</code></pre>

<p>这段代码就是Aspects的调用方式之一，表示在对象aspectsController的buttonPressed函数执行之后，再执行block里的代码，打印一行日志。withOptions的参数写的0，这里是一个枚举值，可以控制block代码怎样执行，具体的定义如下：</p>

<pre><code class="objective-c">typedef NS_OPTIONS(NSUInteger, AspectOptions) {
    AspectPositionAfter   = 0,            /// Called after the original implementation (default)
    AspectPositionInstead = 1,            /// Will replace the original implementation.
    AspectPositionBefore  = 2,            /// Called before the original implementation.

    AspectOptionAutomaticRemoval = 1 &lt;&lt; 3 /// Will remove the hook after the first execution.
};
</code></pre>

<h2>hook过程</h2>

<p>我们从入口函数进入开始跟踪代码，最后发现无论是对实例方法还是类方法进行hook，都会调用aspect_add函数，省略了一些无关代码后如下：</p>

<pre><code class="objective-c">static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) {
    __block AspectIdentifier *identifier = nil;
    AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector);
    identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];
    if (identifier) {
        [aspectContainer addAspect:identifier withOptions:options];

        // Modify the class to allow message interception.
        aspect_prepareClassAndHookSelector(self, selector, error);
    }
    return identifier;
}
</code></pre>

<p>这段代码做了两件事情。</p>

<p>首先生成AspectIdentifier，然后将AspectIdentifier加入到AspectsContainer中。AspectIdentifier的定义如下，它描述了一个Ascpect切片代码的信息。</p>

<pre><code class="objective-c">@interface AspectIdentifier : NSObject
@property (nonatomic, assign) SEL selector;
@property (nonatomic, strong) id block;
@property (nonatomic, strong) NSMethodSignature *blockSignature;
@property (nonatomic, weak) id object;
@property (nonatomic, assign) AspectOptions options;
@end
</code></pre>

<p>AspectsContainer的定义如下，它负责容纳AspectIdentifier，可以在before，instead，after数组里放入多个AspectIdentifier，从名称可以看出这些AspectIdentifier所执行的时机。AspectsContainer将在后边取出并执行。</p>

<pre><code class="objective-c">@interface AspectsContainer : NSObject
@property (atomic, copy) NSArray *beforeAspects;
@property (atomic, copy) NSArray *insteadAspects;
@property (atomic, copy) NSArray *afterAspects;
@end
</code></pre>

<p>其次调用aspect_prepareClassAndHookSelector函数，这是最关键的部分：</p>

<pre><code class="objective-c">static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) {
    Class klass = aspect_hookClass(self, error);
    Method targetMethod = class_getInstanceMethod(klass, selector);
    IMP targetMethodIMP = method_getImplementation(targetMethod);
    if (!aspect_isMsgForwardIMP(targetMethodIMP)) {
        // Make a method alias for the existing method implementation, it not already copied.
        const char *typeEncoding = method_getTypeEncoding(targetMethod);
        SEL aliasSelector = aspect_aliasForSelector(selector);
        if (![klass instancesRespondToSelector:aliasSelector]) {
            __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
        }
        // We use forwardInvocation to hook in.
        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);
    }
}
</code></pre>

<p>这个函数分为两部分，第2行aspect_hookClass和后边的部分。我们先来看aspect_hookClass函数，省略后的代码如下。</p>

<pre><code class="objective-c">static Class aspect_hookClass(NSObject *self, NSError **error) {
    Class statedClass = self.class;
    Class baseClass = object_getClass(self);
    NSString *className = NSStringFromClass(baseClass);

    // Default case. Create dynamic subclass.
    const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;
    Class subclass = objc_getClass(subclassName);

    if (subclass == nil) {
        subclass = objc_allocateClassPair(baseClass, subclassName, 0);
        aspect_swizzleForwardInvocation(subclass);
        aspect_hookedGetClass(subclass, statedClass);
        aspect_hookedGetClass(object_getClass(subclass), statedClass);
        objc_registerClassPair(subclass);
    }

    object_setClass(self, subclass);
    return subclass;
}
</code></pre>

<p>第11行代码通过运行时的函数objc_allocateClassPair定义了一个新的子类。如果是demo执行到这里的话，生成的子类叫AspectsViewController_Aspects。第12行，将子类的forwardInvocation替换为了自定义的实现函数__ASPECTS_ARE_BEING_CALLED__。第18行，将AspectsViewController实例的isa指针指向了子类AspectsViewController_Aspects。</p>

<p>接着，我们继续看aspect_prepareClassAndHookSelector函数的后半部分。第10行在AspectsViewController_Aspects类添加了一个方法aliasSelector，demo中就是aspect_buttonPressed，它的实现指向了原来AspectsViewController类的buttonPressed的实现。第13行，将AspectsViewController_Aspects类的buttonPressed实现指向了_objc_msgForward，这样调用就会启动oc的消息转发机制。</p>

<p>到这里，Aspects这个库的关键初始化流程就执行完了，我们用下边这个图来描述下当前类和方法实现之间的关系。</p>

<p><a href="https://jason5.cn/images/Aspects.png"><img src="https://jason5.cn/images/Aspects.png" alt="" /></a></p>

<p>Aspects的实现为什么要生成一个原有类的子类，个人理解是为了对原有类产生的影响尽可能小。</p>

<h2>hook后的执行流程</h2>

<p>hook完成后，我们来看下hook后代码的执行流程。</p>

<p><strong>这一段很重要！！！</strong>往AspectsViewController实例发送buttonPressed消息的时候，首先应该去查找实例所对应的类的方法列表，由于AspectsViewController的isa指向了AspectsViewController_Aspects类，就会去AspectsViewController_Aspects类中查找，结果是查找不到buttonPressed实现，然后会去查找父类AspectsViewController的方法列表，这时候查找到了buttonPressed的实现，但是实现是指向了_msg_forward，这样就进入了消息转发流程。按照消息转发流程，系统会调用AspectsViewController_Aspects类的forwardInvocation方法，forwardInvocation方法被我们替换成了自定义实现__ASPECTS_ARE_BEING_CALLED__，最终就进入了这个方法。</p>

<p>__ASPECTS_ARE_BEING_CALLED__的省略后的代码如下：</p>

<pre><code class="objective-c">// This is the swizzled forwardInvocation: method.
static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) {
    SEL originalSelector = invocation.selector;
    SEL aliasSelector = aspect_aliasForSelector(invocation.selector);
    invocation.selector = aliasSelector;
    AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector);
    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector);
    AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation];
    NSArray *aspectsToRemove = nil;

    // Before hooks.
    aspect_invoke(classContainer.beforeAspects, info);
    aspect_invoke(objectContainer.beforeAspects, info);

    // Instead hooks.
    BOOL respondsToAlias = YES;
    if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) {
        aspect_invoke(classContainer.insteadAspects, info);
        aspect_invoke(objectContainer.insteadAspects, info);
    }else {
        Class klass = object_getClass(invocation.target);
        do {
            if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) {
                [invocation invoke];
                break;
            }
        }while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));
    }

    // After hooks.
    aspect_invoke(classContainer.afterAspects, info);
    aspect_invoke(objectContainer.afterAspects, info);
}
</code></pre>

<p>第7行，对于hook的实例方法，先拿到之前设置的切片代码信息，存储在classContainer里。第24行，通过invocation调用AspectsViewController_Aspects的aspect_buttonPressed方法，由于这个方法已经指向了原来的实现buttonPressed，所以就调用了原始的代码。在这之后，如果Container里有afterAspects，就调用切片的block。beforeAspects同理。</p>

<p>到此为止，就实现了在原来的实例方法执行后，再执行hook插入的block代码。</p>

<h2>总结</h2>

<p>ios的runtime是黑魔法，运用起来可以做很多强大的功能。总的来讲，Aspects利用了ios的method swizzling和消息转发机制forwordInvocation，实现了对函数进行切片hook。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对JSPatch原理的理解]]></title>
    <link href="http://jason5.cn/blog/dui-jspatchyuan-li-de-li-jie.html"/>
    <updated>2018-11-08T15:08:47+08:00</updated>
    <id>http://jason5.cn/blog/dui-jspatchyuan-li-de-li-jie</id>
    <content type="html"><![CDATA[<p>JSPatch利用OC语言的动态特性，让OC语言根据传入的JS代码，进行动态行为修改，以达到热更新的目的。</p>

<p>项目中根据JSPatch的原理，自己实现了一套简单的热更新方案。以替换方法实现为例，热更新运行的步骤如下：</p>

<p>1.补丁下发阶段</p>

<p>应用启动的时候，会加载下发的补丁js文件，以下这一段热更新代码会被执行。</p>

<pre><code class="javascript">replaceMethod("IGTabBarController", "onNaviBarTaskBoxClick:", false, function (invocation) {
    log("origin method");
    callOriginMethod(invocation, "origin_onNaviBarTaskBoxClick:");
});
</code></pre>

<p>OC中的JSContext在初始化的时候加载过replaceMethod函数，所以会调用到OC代码</p>

<pre><code>ocReplaceMethod:(NSString *)className selectorName:(NSString *)selectorName isClass:(BOOL)isClass func:(JSValue *)func
</code></pre>

<p>这个函数里，做了一个重要的逻辑（这里参考了JSPatch的实现方式），将IGTabBarController的实例方法onNaviBarTaskBoxClick:指向了forwardInvocation:，然后自定义实现PMDForwardInvocation替换forwardInvocation:的行为</p>

<p>2.用户调用阶段</p>

<p>用户操作点击后，IGTabBarController的onNaviBarTaskBoxClick:会被执行，从而PMDForwardInvocation被执行，根据OC的函数转发特性，PMDForwardInvocation会拿到所有的函数参数信息invocation。然后调用<code>jsfunc(@[invocation])</code>。这样就将所有原生参数通过invocation对象传回给了js代码。js代码拿到这些参数就可以去实现任何逻辑了，以达到替换原方法的目的。</p>

<p>总结：这里是一个很重要的技巧，如何将需要动态更新的OC方法的参数全部传给js代码，JSPatch是利用了forwardInvocation的特性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TIP项目网络框架梳理]]></title>
    <link href="http://jason5.cn/blog/tipxiang-mu-wang-luo-kuang-jia-shu-li.html"/>
    <updated>2018-10-23T16:07:12+08:00</updated>
    <id>http://jason5.cn/blog/tipxiang-mu-wang-luo-kuang-jia-shu-li</id>
    <content type="html"><![CDATA[<p>前段时间小伙伴重构了项目的网络层代码，将之前的过程式的代码，面向对象化了，职责分离，更易维护。不过也增加了理解成本，这里记录一下。</p>

<p>整个网络模块的类图如下。PMD开头的类下沉到了基础库，IG开头的类仍然在项目中。</p>

<p><a href="https://jason5.cn/images/tip-network-uml.jpg"><img src="https://jason5.cn/images/tip-network-uml.jpg" alt="" /></a></p>

<ul>
<li>IGNetworkManager作为项目中使用网络层的入口类，不多做介绍。</li>
<li>PMDNetworking是发起网络请求的类，这里首先要用PMDCallFactory工厂类，生成一个实现PMDCall协议的对象，然后调用makeCallWithRequest方法进行网络请求。</li>
<li>PMDCallFactory用于生成PMDCall协议对象</li>
<li>PMDCall协议对象为了避免被回收，放到了PMDCallPool里进行管理</li>
<li>PMDBaseCall实现了PMDCall协议，完成了主要的网络请求逻辑。分为以下几个步骤</li>
</ul>


<p>1.callWithRequest准备发起网络请求</p>

<p>2.dealWithInterceptResult遍历所有PMDIntercept，在真正发起网络请求前进行逻辑处理，处理的过程中可以中断。</p>

<p>3.realCallWithRequest真正发起网络请求，这里的实现交给继承类IGCall来实现，具体的实现可以是http，也可以是tcp，在TIP项目中用到了IGNetworkObject去发网路请求。</p>

<p>4.convertResponse将请求回来的数据，遍历PMDConverter进行处理。</p>

<ul>
<li>PMDInterceptor和PMDConverter协议分别是需要在网络请求发出之前和之后要处理的逻辑，只要实现此协议，加入到PMDBaseCall中就可以了。</li>
</ul>


<p>基本的结构就是这样了，除此之外，框架还实现了取消发送，重新发送等逻辑，这里不再详细介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对iOS App签名的理解]]></title>
    <link href="http://jason5.cn/blog/dui-ios-appqian-ming-de-li-jie.html"/>
    <updated>2018-10-22T11:23:43+08:00</updated>
    <id>http://jason5.cn/blog/dui-ios-appqian-ming-de-li-jie</id>
    <content type="html"><![CDATA[<p>关于iOS设备签名的原理，这篇文章说的比较清楚了。如果忘了的话可以重新阅读以下。</p>

<p><a href="http://blog.cnbang.net/tech/3386/">iOS App 签名的原理</a></p>

<p>这里按照我的理解角度复述一下：</p>

<ol>
<li>为了不让每次开发App，都将App上传到苹果后台，用苹果后台的私钥A签名，需要本地生成一对公私钥。这样每次签名就在本地Mac机器上，用私钥L签名就可以了。</li>
<li>那么苹果如果验证公钥L的合法性呢，就需要开发者将公钥L上传到苹果的后台，苹果用私钥A进行一次签名，签名+公钥L就是证书了。（这里实际上用一次对公钥L的签名替代了每次对App的签名，省去了App每次修改都上传签名的麻烦，很巧妙）</li>
<li>第2步中的证书+一些额外信息（AppId，设备列表，push权限等）全部都在苹果的后台用私钥A签名，打包成的东西叫Provisioning Profile，下载到本地Mac后，打包在App中。安装在iOS设备的时候，用公钥A对其进行解密，验证证书+一些额外信息（AppId，设备列表，push权限等。证书验证后拿到公钥L，对App数据进行解密验证（App是用私钥L签名的）。</li>
</ol>


<p>好了，上边的文字其实看着还是有点乱和绕，权当我自己的思路做参考吧。</p>

<p>回到我们的项目，其实有一点是可以改进的。</p>

<p><img src="https://jason5.cn/images/WX20181022-114418@2x.png" alt="" /></p>

<p>以上图片是我们项目在苹果后台的证书配置，可以看到，有很多项，原因是每个开发的电脑上都生成了一对公钥L和私钥L，然后将公钥L上传到苹果后台生成了证书。更好的办法是，只用一台开发电脑生成公钥L和私钥L，然后到处p12文件，分享给别的电脑，这样苹果后台就只需要一个证书就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发中支持实时UI调试的方法]]></title>
    <link href="http://jason5.cn/blog/ioskai-fa-zhong-zhi-chi-shi-shi-uidiao-shi-de-fang-fa.html"/>
    <updated>2018-10-18T14:02:46+08:00</updated>
    <id>http://jason5.cn/blog/ioskai-fa-zhong-zhi-chi-shi-shi-uidiao-shi-de-fang-fa</id>
    <content type="html"><![CDATA[<h3>背景</h3>

<p>平时在开发iOS界面的过程中，如果修改了布局代码，需要重新启动模拟器，进行效果查看。如果工程较大，启动将耗时比较长，比较浪费时间。这里介绍一个工具InjectionIII，使用后可以不重启应用，保存文件后直接查看修改效果，极大提升界面开发工作的效率。</p>

<h3>使用方法</h3>

<p>1.在App Store下载InjectionIII</p>

<p>2.在应用启动函数 加入以下代码</p>

<pre><code class="objective-c">#if DEBUG
    NSBundle *bundle = [NSBundle bundleWithPath:@"/Applications/InjectionIII.app/Contents/Resources/iOSInjection10.bundle"];
    [bundle load];
#endif
</code></pre>

<p>3.启动InjectionIII，重启XCode，然后用模拟器启动应用。状态栏上有InjectionIII的小图标，确认File Watcher选项已经勾选。这时候修改文件，只要保存，在模拟器界面上会立即更新效果</p>

<p>PS: 这个工具的缺点是只支持模拟器，原因参见原理部分。</p>

<h3>原理</h3>

<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTQ2NzE0NQ==&amp;mid=2247483999&amp;idx=1&amp;sn=bc88d37b6f819bd6bd7d8b76e9787620&amp;chksm=a6f958b9918ed1af9a084ce2c2732aaee715193e37fdb830dc31d8f0174c0314b22dc5c0dd1e&amp;mpshare=1&amp;scene=1&amp;srcid=0612tT8PS1pePiL5EmqMr9HH#rd">Injection：iOS热重载背后的黑魔法</a></p>
]]></content>
  </entry>
  
</feed>
