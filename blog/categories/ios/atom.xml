<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：ios | 移动开发技术]]></title>
  <link href="http://jason5.cn/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://jason5.cn/"/>
  <updated>2018-04-03T19:53:07+08:00</updated>
  <id>http://jason5.cn/</id>
  <author>
    <name><![CDATA[jason]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[利用Weex DevTool调试Native应用-iOS篇]]></title>
    <link href="http://jason5.cn/blog/li-yong-weex-devtooldiao-shi-nativeying-yong-iospian.html"/>
    <updated>2018-04-03T17:48:04+08:00</updated>
    <id>http://jason5.cn/blog/li-yong-weex-devtooldiao-shi-nativeying-yong-iospian</id>
    <content type="html"><![CDATA[<p>官方的文档里说提供了一个工具DevTool，用来调试原生应用，但是写得比较简略，一直跑不起来，经过几天折腾和查资料，基本上是可以调试了，记录一下步骤和问题。</p>

<h3>1. 先在本机安装iOS的调试工具</h3>

<p>工具地址是 <a href="https://github.com/weexteam/weex-devtool-iOS">https://github.com/weexteam/weex-devtool-iOS</a></p>

<pre><code class="javascript">npm install -g weex-devtool
</code></pre>

<p>运行调试工具weex-devtool，启动成功后，在终端命令行里会显示如下两行信息。</p>

<p><a href="http://jason5.cn/images/QQ20180403-181423.png"><img src="http://jason5.cn/images/QQ20180403-181423.png" alt="" /></a></p>

<p>Websocket Address For Native是调试工具暴露的一个websocket地址，用于和Native之间的双向通信，之后Native中的代码会用到。
Debug Server是调试工具提供的一个web服务地址，开发者通过这个网页可以像调试web页面一样，来调试Native应用。</p>

<h3>2. 将WXDevTool集成到项目工程中</h3>

<p>增加podfile文件，只在Debug模式下集成WXDevtool</p>

<pre><code class="javascript">pod 'WXDevtool',   '0.15.3', :configurations =&gt; ['Debug']
</code></pre>

<p>这里遇到两个问题</p>

<p>（1）集成后编不过，根据提示发现这个库和项目里用到的FLEX有冲突，所以暂时去掉了FLEX。希望后续升级版本能解决这两个库之间的冲突。</p>

<p>（2）发现还编不过，是需要再集成一个依赖库SocketRocket</p>

<pre><code>pod 'SocketRocket', '0.4.2'
</code></pre>

<h3>3. 在App启动的时候加入如下代码</h3>

<pre><code class="objc">[WXDevTool setDebug:YES];
[WXDevTool launchDevToolDebugWithUrl:@"ws://10.32.194.33:8088/debugProxy/native"];
</code></pre>

<p>这里launchDevToolDebugWithUrl函数需要传一个参数，就是在第一步中的websocket地址。</p>

<h3>4. 开始调试</h3>

<p>如果之前一切顺利的话，现在就可以调试了。网页打开调试地址<a href="http://10.32.194.33:8088">http://10.32.194.33:8088</a>  <br/>
启动Native App，然后会看到我们的App信息出现在网页中。</p>

<p><a href="http://jason5.cn/images/QQ20180403-182830.png"><img src="http://jason5.cn/images/QQ20180403-182830.png" alt="" /></a></p>

<p>可以看到下边两个黑色的大按钮，是调试工具提供的两个功能，Debugger和Inspector。
Debugger用来调试js代码。在里边可以给代码设置断点，观察变量值，查看console.log的输出，跟Web开发一样的体验。</p>

<p><a href="http://jason5.cn/images/QQ20180403-193719.png"><img src="http://jason5.cn/images/QQ20180403-193719.png" alt="" /></a></p>

<p>Inspector用来调试UI界面。这里可以看到界面的树形结构，可以直接修改位置等属性，可以实时看到效果。这里如果在终端操作页面，浏览器里的页面也是会实时刷新的。</p>

<p><a href="http://jason5.cn/images/QQ20180403-193917.png"><img src="http://jason5.cn/images/QQ20180403-193917.png" alt="" /></a></p>

<p>这里遇到了一个问题，启动App后，必须首先进入Debugger页面打开调试工具，Native里的weex页面才能被正常渲染和执行，暂时还没搞清楚原因。</p>

<h3>5.总结</h3>

<p>调试工具可以让开发Native的时候，像Web开发一样去调试，一定程度上提高了效率，对熟悉Web开发的同学来讲，应该能很快上手。</p>

<p>PS：下一篇文章会讲一下原生页面和weex页面之间的跳转以及在weex中如何自定义导航栏。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Weex中js和Native的交互-iOS篇]]></title>
    <link href="http://jason5.cn/blog/weexzhong-jshe-nativede-jiao-hu-iospian.html"/>
    <updated>2018-03-27T11:21:56+08:00</updated>
    <id>http://jason5.cn/blog/weexzhong-jshe-nativede-jiao-hu-iospian</id>
    <content type="html"><![CDATA[<p>终端集成Weex后，看了下js调用Native的方法，做了个展示列表的demo，做下记录。</p>

<p><img src="http://jason5.cn/images/QQ20180327-105246.png" alt="" /></p>

<!--more-->


<h2>Native端</h2>

<p>要实现Weex调用Native，需要实现自定义的module，暴露相应的方法，并且注册。完成这个过程后，js里可以直接注册过的module中的方法，并且通过callback拿到返回结果。下边以weex调用native的网络模块获取数据并进行展示的例子，进行介绍。</p>

<h3>1. 实现WXModuleProtocol协议</h3>

<p>自定义module，需要实现WXModuleProtocol协议</p>

<p>WXCustomNetworkModule.h</p>

<pre><code class="objc">@interface WXCustomNetworkModule : NSObject&lt;WXModuleProtocol&gt;
@end
</code></pre>

<h3>2. 实现网络请求数据的方法，并且暴露给js</h3>

<p>WXCustomNetworkModule.m</p>

<pre><code class="objc">@interface WXCustomNetworkModule()

@property (nonatomic, strong) NSMutableArray *merchants;
@property (nonatomic, copy) NSString *pageIndex;

@end

@implementation WXCustomNetworkModule

WX_EXPORT_METHOD(@selector(getMerchantList:))

-(void)getMerchantList:(WXModuleCallback)callback{

    TipCredit_QueryMerchantCreditListReq *req = [[TipCredit_QueryMerchantCreditListReq alloc] init];
    req.userLng = [CPLocationAPI getLongitude];
    req.userLat = [CPLocationAPI getLatitude];
    req.pageidx = self.pageIndex;
    req.num = 10;

    @weakify(self);
    [TipNetWorkManager requestWithReq:req withRspClass:[TipCredit_QueryMerchantCreditListRsp class] withCmd:90086 successBlock:^(id respondObjc) {
        @strongify(self);
        TipCredit_QueryMerchantCreditListRsp *rsp = (TipCredit_QueryMerchantCreditListRsp *)respondObjc;
        self.pageIndex = rsp.pageidx;
        [self.merchants addObjectsFromArray:rsp.merchantcreditsArray];

        for(int i=0; i&lt;self.merchants.count; i++){
            self.merchants[i] = [self.merchants[i] toJson];
        }
        callback(self.merchants);

    } failedBlock:^(id failedMsg, int resultCode) {
        @strongify(self);
    }];
}
</code></pre>

<p>getMerchantList是发送网络请求获取后台数据的方法。</p>

<pre><code class="objc">WX_EXPORT_METHOD(@selector(getMerchantList:))
</code></pre>

<p>这行代码可以将此函数暴露给js调用。</p>

<h3>3. 初始化的时候注册自定义module，并且指定module name</h3>

<pre><code class="objc">[WXSDKEngine registerModule:@"network" withClass:[WXCustomNetworkModule class]];
</code></pre>

<p>module name命名为network，表示网络模块。</p>

<h3>4. js拿到回调数据</h3>

<p>实现的方法，在最后可以加一个WXModuleCallback类型的callback参数</p>

<pre><code class="objc">callback(self.merchants);
</code></pre>

<p>通过这行代码将结果回调给js。回调的参数类型支持NSString, NSArray, NSDictionary。所以这里回调之前，将网络返回的自定义类转换成了NSDictionary，再进行回调。</p>

<h2>js端</h2>

<p>```javascript
<template>
  <list class="list">
    <cell class="cell" v-for="merchant in lists">
      <div class="panel">
        <text class="text"></text>
      </div>
    </cell>
  </list>
</template></p>

<script>
export default {
  name: 'App',
  components: {
    HelloWorld
  },
  data () {
    return {
      logo : 'https://gw.alicdn.com/tfs/TB1yopEdgoQMeJjy1XaXXcSsFXa-640-302.png',
      lists : []
    }
  },
  methods: {
  
  },
  created: function () {
    var self = this
    weex.requireModule('network').getMerchantList(function(rsp){
      self.lists = rsp
    })
  }
}
</script>


<pre><code>index.vue的关键代码如上。created方法在页面创建时候会执行。通过
</code></pre>

<p>weex.requireModule(&lsquo;network&rsquo;).getMerchantList
```
这行代码，调用原生网络模块，并且拿到回调数据进行展示。</p>

<h2>总结</h2>

<p>本文介绍了Weex中js与Native的交互方式。通过此方法，界面部分完全可以在js里实现，iOS和Android双端只写一份，原生部分只需要提供负责网络请求的module就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[集成Weex到现有应用-iOS篇]]></title>
    <link href="http://jason5.cn/blog/ji-cheng-weexdao-xian-you-ying-yong-iospian.html"/>
    <updated>2018-03-26T11:48:50+08:00</updated>
    <id>http://jason5.cn/blog/ji-cheng-weexdao-xian-you-ying-yong-iospian</id>
    <content type="html"><![CDATA[<p>最近看了一下weex，将weex集成到了现有的iOS APP里，并且实现了一个静态页面的展示，做下记录。</p>

<!--more-->


<h2>一. 现有iOS应用的修改</h2>

<h3>1. 用cocopods引入WeexSDK</h3>

<pre><code class="bash">pod 'WeexSDK', '0.18.0'
</code></pre>

<h3>2. 在iOS APP里初始化Weex</h3>

<p>didFinishLaunchingWithOptions里添加代码</p>

<pre><code class="objc">//business configuration
[WXAppConfiguration setAppGroup:@"TencentApp"];
[WXAppConfiguration setAppName:@"TIP"];
[WXAppConfiguration setAppVersion:@"1.0.0"];

//init sdk environment
[WXSDKEngine initSDKEnvironment];

//register custom module and component，optional
//这里暂时用不到，之后再说
//[WXSDKEngine registerComponent:@"MyView" withClass:[MyViewComponent class]];
//[WXSDKEngine registerModule:@"event" withClass:[WXEventModule class]];

//register the implementation of protocol, optional
//如果在weex页面里需要下载网络图片，需要自己实现协议，如果没有，可以注释掉
[WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)];
//set the log level
[WXLog setLogLevel: WXLogLevelAll];
</code></pre>

<h3>3. 在业务相关页面用weex渲染原生View</h3>

<pre><code class="objc">@interface IGWeexDemoViewController()

@property (nonatomic, strong) WXSDKInstance *instance;
@property (nonatomic, strong) UIView *weexView;
@property (nonatomic, strong) NSString *url;
@end

@implementation IGWeexDemoViewController

-(void)viewDidLoad{
    [super viewDidLoad];

//    self.url = @"http://10.66.212.209:8081/dist/index.js";
    self.url = @"http://weex-1251917893.cosgz.myqcloud.com/index.js";

    _instance = [[WXSDKInstance alloc] init];
    _instance.viewController = self;
    _instance.frame = self.view.frame;

    __weak typeof(self) weakSelf = self;
    _instance.onCreate = ^(UIView *view) {
        [weakSelf.weexView removeFromSuperview];
        weakSelf.weexView = view;
        [weakSelf.view addSubview:weakSelf.weexView];
    };

    _instance.onFailed = ^(NSError *error) {
        //process failure
    };

    _instance.renderFinish = ^ (UIView *view) {
        //process renderFinish
    };
    [_instance renderWithURL:[NSURL URLWithString:self.url]];
}

- (void)dealloc{
    [_instance destroyInstance];
}
</code></pre>

<h3>4. 运行效果</h3>

<p><img src="http://jason5.cn/images/QQ20180326-114148.png" alt="" /></p>

<h2>二. 生成js文件</h2>

<p>在第一张的第3节中，原生View通过加载一个js文件，然后用Weex SDK进行渲染。这一章介绍js文件的生成方法。</p>

<h3>1. 安装node</h3>

<pre><code class="bash">brew install node
</code></pre>

<h3>2. 安装weex-toolkit</h3>

<pre><code class="bash">npm install -g weex-toolkit
</code></pre>

<h3>3. 初始化weex工程</h3>

<pre><code class="bash">weex create awesome-project
</code></pre>

<p>然后在项目根目录运行
<code>bash
npm install
</code>
安装项目依赖</p>

<h3>4. 生成原生用到的js文件</h3>

<pre><code class="bash">npm run serve
</code></pre>

<p>运行这个命令，会在本地启动一个http server，原生终端用到的js文件就可以通过url访问了。生成的js在dist目录下，找到之后就可以拼出js的url了，例如
<a href="http://10.66.212.209:8081/dist/index.js%E3%80%82">http://10.66.212.209:8081/dist/index.js%E3%80%82</a></p>

<h2>三. 如何显示网络图片</h2>

<p>运行demo后，会发现网络图片不能展示。原来weex初始并没有集成网络图片下载功能，需要自己去实现。方法如下</p>

<h3>1.自定义图片下载协议WXImgLoaderProtocol</h3>

<pre><code class="objc">@protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;
-(id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image,  NSError *error, BOOL finished))completedBlock;
@end
</code></pre>

<h3>2.协议的实现类WXImgLoaderDefaultImpl</h3>

<pre><code class="objc">//WXImgLoaderDefaultImpl.h文件
@interface WXImgLoaderDefaultImpl : NSObject
@end

//WXImgLoaderDefaultImpl.m文件
@implementation WXImgLoaderDefaultImpl
#pragma mark WXImgLoaderProtocol

- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)userInfo completed:(void(^)(UIImage *image,  NSError *error, BOOL finished))completedBlock
{
    if ([url hasPrefix:@"//"]) {
        url = [@"http:" stringByAppendingString:url];
    }
    return (id&lt;WXImageOperationProtocol&gt;)[[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) {
    } completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {
        if (completedBlock) {
            completedBlock(image, error, finished);
        }
    }];
}
@end
</code></pre>

<h3>3.在weex初始化的时候注册协议</h3>

<pre><code class="objc">[WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)];
</code></pre>

<h2>四. todo</h2>

<p>后续还有一些问题要研究</p>

<ol>
<li>weex页面里，如何调用native的网络模块获取到数据</li>
<li>多页面的跳转</li>
<li>调试工具weex devtool的使用方法</li>
<li>如何构建发布流程</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何查看p12文件的信息]]></title>
    <link href="http://jason5.cn/blog/ru-he-cha-kan-p12wen-jian-de-xin-xi.html"/>
    <updated>2017-12-16T14:37:21+08:00</updated>
    <id>http://jason5.cn/blog/ru-he-cha-kan-p12wen-jian-de-xin-xi</id>
    <content type="html"><![CDATA[<pre><code>openssl pkcs12 -in xxx.p12 -out xxx.pem -nodes
</code></pre>

<p>pem文件可以直接用文本工具打开</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转]到底什么时候才需要在ObjC的Block中使用weakSelf/strongSelf]]></title>
    <link href="http://jason5.cn/blog/zhuan-dao-di-shi-yao-shi-hou-cai-xu-yao-zai-objcde-blockzhong-shi-yong-weakself-slash-strongself.html"/>
    <updated>2017-06-16T15:01:32+08:00</updated>
    <id>http://jason5.cn/blog/zhuan-dao-di-shi-yao-shi-hou-cai-xu-yao-zai-objcde-blockzhong-shi-yong-weakself-slash-strongself</id>
    <content type="html"><![CDATA[<p>Objective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self->theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。</p>

<!--more-->


<h2>解决 retain circle</h2>

<p>Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。</p>

<p>示例代码：</p>

<pre><code>__weak __typeof__(self) weakSelf = self;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [weakSelf doSomething];
});
</code></pre>

<p>clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：</p>

<pre><code>__weak __typeof__(self) weakSelf = self;
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [weakSelf doSomething];
    [weakSelf doOtherThing];
});
</code></pre>

<p>在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：</p>

<pre><code>__weak __typeof__(self) weakSelf = self;
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    __strong __typeof(self) strongSelf = weakSelf;
    [strongSelf doSomething];
    [strongSelf doOtherThing];
});
</code></pre>

<p>__strong 确保在 Block 内，strongSelf 不会被释放。</p>

<h2>总结</h2>

<ul>
<li>在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。</li>
<li>如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。</li>
</ul>


<h2>参考</h2>

<ul>
<li><a href="https://dhoerl.wordpress.com/2013/04/23/i-finally-figured-out-weakself-and-strongself">I finally figured out weakSelf and strongSelf</a></li>
<li><a href="https://stackoverflow.com/questions/21113963/is-the-weakself-strongself-dance-really-necessary-when-referencing-self-inside-a?rq=1">Is the weakSelf/strongSelf dance really necessary when referencing self inside a non-retained completion called from a UIViewController?</a></li>
</ul>


<blockquote><p> 原文链接： <a href="http://blog.lessfun.com/blog/2014/11/22/when-should-use-weakself-and-strongself-in-objc-block/">http://blog.lessfun.com/blog/2014/11/22/when-should-use-weakself-and-strongself-in-objc-block/</a></p></blockquote>
]]></content>
  </entry>
  
</feed>
